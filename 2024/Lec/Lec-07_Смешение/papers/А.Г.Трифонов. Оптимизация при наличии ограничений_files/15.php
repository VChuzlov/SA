<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="Description"content="Консультационный центр MATLAB: раздел Optimization Toolbox."><meta name="Keywords"content="MATLAB, Matlab, матлаб, МАТЛАБ, Optimization Toolbox, оптимизация"><title>А.Г.Трифонов. Оптимизация при наличии ограничений</title><link href="../../styles/default.css" rel="stylesheet" type="text/css"></head><body marginwidth="0" marginheight="0" leftmargin="0" topmargin="0" background="#FFFFFF">
<link href="/favicon.ico" rel="icon" type="image/x-icon" />
<link href="/favicon.ico" rel="shortcut icon" type="image/x-icon" />

<table border="0" cellpadding="0" cellspacing="0">
	<tr>
		<td height="1">
		<!-- GA-->
		<script type="text/javascript">
	var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
	document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
	var pageTracker = _gat._getTracker("UA-8620903-6");
	pageTracker._trackPageview();
} catch(err) {}
</script>
		<!-- /GA-->
		<!-- Yandex.Metrika counter -->
<script type="text/javascript">
(function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter20978398 = new Ya.Metrika({id:20978398,
                    webvisor:true,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
})(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="//mc.yandex.ru/watch/20978398" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

		</td>
	</tr>
</table>

<table border="0" cellpadding="0" cellspacing="0" align="center">
<tr><td>
<table border="0" cellpadding="0" cellspacing="0" align="center">
<tr><td>


<table BORDER=0 CELLPADDING=0 CELLSPACING=0 height="116" width="780">
	<tr>
		<td colspan=6><a href="/" class="bg-matlab-header">MATLAB.Exponenta</a></td>
	</tr>
	<tr>
		<td valign="top" colspan=6 height="1" bgcolor="white"></td>
	</tr>
	<tr>
		<td colspan=5 bgcolor="black" height="16"><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0 width="100%" height="16">
	<TR><TD align="center" class="navblack" onmouseover=eval('this.className='+'"navgray"')  onmouseout=eval('this.className='+'"navblack"')>&nbsp;<a class="topnav" href="/">Материалы</a>&nbsp;</TD><TD width="1" bgcolor="white"><img src="/images/wdot.gif" width="1" height="1"></TD>
<TD align="center" class="navblack" onmouseover=eval('this.className='+'"navgray"')  onmouseout=eval('this.className='+'"navblack"')>&nbsp;<a class="topnav" href="http://matlab.ru/seminars">Семинары</a>&nbsp;</TD><TD width="1" bgcolor="white"><img src="/images/wdot.gif" width="1" height="1"></TD>
<TD align="center" class="navblack" onmouseover=eval('this.className='+'"navgray"')  onmouseout=eval('this.className='+'"navblack"')>&nbsp;<a class="topnav" href="http://matlab.ru/webinars">Вебинары</a>&nbsp;</TD><TD width="1" bgcolor="white"><img src="/images/wdot.gif" width="1" height="1"></TD>
<TD align="center" class="navblack" onmouseover=eval('this.className='+'"navgray"')  onmouseout=eval('this.className='+'"navblack"')>&nbsp;<a class="topnav" href="/forum">Форум</a>&nbsp;</TD><TD width="1" bgcolor="white"><img src="/images/wdot.gif" width="1" height="1"></TD>
<TD align="center" class="navblack" onmouseover=eval('this.className='+'"navgray"')  onmouseout=eval('this.className='+'"navblack"')>&nbsp;<a class="topnav" href="http://matlab.ru/products">Список продуктов</a>&nbsp;</TD><TD width="1" bgcolor="white"><img src="/images/wdot.gif" width="1" height="1"></TD>
<TD align="center" class="navblack" onmouseover=eval('this.className='+'"navgray"')  onmouseout=eval('this.className='+'"navblack"')>&nbsp;<a class="topnav" href="http://matlab.ru">matlab.ru</a>&nbsp;</TD><TD width="1" bgcolor="white"><img src="/images/wdot.gif" width="1" height="1"></TD>
<TD align="center" class="navblack" onmouseover=eval('this.className='+'"navgray"')  onmouseout=eval('this.className='+'"navblack"')><a class="topnav" href="http://matlab.exponenta.ru/forum/ucp.php?mode=register">Регистрация</a></TD>
</TR>
</TABLE>
</td>
		<td width="125" rowspan=6 valign="top"><TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 width="100%" height="100%">
<TR>
<TD bgcolor="white" width="1"></TD>
<TD HEIGHT=100% valign="top">

<TABLE CELLSPACING = 0 CELLPADDING = 0 BORDER = 0 width="100%" height="100%">
<TR>
<TD class="navright" WIDTH=124 height="16" onmouseover=eval('this.className='+'"navblack"')  onmouseout=eval('this.className='+'"navright"')> &nbsp;&nbsp;&nbsp;<a style="color:white;" href="/matlab/default.php">Matlab</a></TD>
</TR>
  <TR><TD bgcolor="white" height="1"></td></TR>  <TR>  <TD class="navright" WIDTH=124 onmouseover=eval('this.className='+'"navblack"')  onmouseout=eval('this.className='+'"navright"')>&nbsp;&nbsp;&nbsp;<a style="color:white;" href="/curvefitting/index.php">Toolboxes</a>    </TD>      </TR>
  <TR><TD bgcolor="white" height="1"></td></TR>  <TR>  <TD class="navright" WIDTH=124 onmouseover=eval('this.className='+'"navblack"')  onmouseout=eval('this.className='+'"navright"')>&nbsp;&nbsp;&nbsp;<a style="color:white;" href="/simulink/default.php">Simulink</a>    </TD>      </TR>
  <TR><TD bgcolor="white" height="1"></td></TR>  <TR>  <TD class="navright" WIDTH=124 onmouseover=eval('this.className='+'"navblack"')  onmouseout=eval('this.className='+'"navright"')>&nbsp;&nbsp;&nbsp;<a style="color:white;" href="/aerospace/index.php">Blocksets</a>    </TD>      </TR>
<!--  <TR><TD bgcolor="white" height="1"></td></TR>  <TR>  <TD class="navright" WIDTH=124 onmouseover=eval('this.className='+'"navblack"')  onmouseout=eval('this.className='+'"navright"')>&nbsp;&nbsp;&nbsp;<a style="color:white;" href="/femlab/default.php">Femlab</a>    </TD>      </TR>
  <TR><TD bgcolor="white" height="1"></td></TR>  <TR>  <TD class="navright" WIDTH=124 onmouseover=eval('this.className='+'"navblack"')  onmouseout=eval('this.className='+'"navright"')>&nbsp;&nbsp;&nbsp;<a style="color:white;" href="/applarea/all.php">3rd-Party Products</a>    </TD>      </TR>
-->
  <TR><TD bgcolor="white" height="1"></td></TR>  <TR>  <TD class="navright" WIDTH=124 onmouseover=eval('this.className='+'"navblack"')  onmouseout=eval('this.className='+'"navright"')>&nbsp;&nbsp;&nbsp;<a style="color:white;" href="/books/default.php">Полезное</a>    </TD>      </TR>
</TABLE>

</TD>
</TR>
</TABLE></td>
	</tr>
	<tr>
		<td colspan=6 valign="top" height="1" bgcolor="white"></td>
	</tr>
	<tr>
		<td valign="top" rowspan="4"><a href="/"><img src="/images/mltb.gif" WIDTH=315 border="0" alt="вЂ“Г›В·пЈїГ‹ГЌвЂЎ Matlab&Toolboxes"></a></td>
		<td><img src="/images/new1_12.gif" WIDTH=116 HEIGHT=20 border="0"></td>
		<td><img src="/images/new1_13.gif" WIDTH=87 HEIGHT=20></td>
		<td colspan=2><img src="/images/new1_14.gif" WIDTH=138 HEIGHT=20></td>
	</tr>
	<tr>
		<td colspan=4 background="/images/m-block.gif" WIDTH=341 HEIGHT=22>
			<!--<script language="Javascript" type="text/javascript" src="http://allsoft.ru/ads/newban.php?Code=MATLABTOP&t=top&rnd=1470931010"></script>-->
			<ul class="b-list-url">
				<li class="b-list-url__item"><a href="http://matlab.ru/price" target="_blank" >Запрос цены</a></li>
				<li class="b-list-url__item"><a href="http://matlab.ru/trial" target="_blank" >Запрос пробной версии</a></li>
				<li class="b-list-url__item b-list-url__item_last"><a href="http://matlab.ru/training" target="_blank" >Тренинги</a></li>
			</ul>
		</td>
	</tr>
	<tr>
		<td><img src="/images/new1_22.gif" WIDTH=116 HEIGHT=19></td>
		<td><img src="/images/new1_23.gif" WIDTH=87 HEIGHT=19></td>
		<td><img src="/images/new1_241.gif" WIDTH=93 HEIGHT=19></td>
		<td><img src="/images/new1_242.gif" WIDTH=45 HEIGHT=19></td>
	</tr>
	<tr>
		<td><img src="/images/new1_27.gif" WIDTH=116 HEIGHT=25></td>
		<td><img src="/images/new1_28.gif" WIDTH=87 HEIGHT=25></td>
		<td WIDTH=93 HEIGHT=25 align="center">
		<!--<a class="login"  href="../../forum_old/login.php?redirect=../optimiz/book_1/15.php"><span class="text1">Вход</span></a>--></td>
		<td><img src="/images/new1_291.gif" WIDTH=45 HEIGHT=25></td>
	</tr>

	
	
</table>

<!--<table BORDER=0 CELLPADDING=0 CELLSPACING=0 width="780" height="20" border="1">
	<tr>
		<td><marquee border="1" width="775" behavior="scroll" direction="left" scrollamount="1" scrolldelay="30" truespeed height="13"><strong><font color="BLUE"><a href="http://matlab.exponenta.ru/forum/conf2009/default.php" target="_blank">4Г±8 ГЏвЂЎЛ‡ 2009 вЂћГ“вЂ°вЂЎ Г’Г“Г’ГљГ“Г‹ГљГ’Л‡ IV В¬Г’Г‚пЈїГ“Г’Г’Г‹Г€Г’ГЌвЂЎЛ‡ ГЊвЂЎГ›ЛњГЊвЂЎЛ‡ ГЌГ“ГЊГ™Г‚пЈїГ‚ГЊЛ†Г‹Л‡ ВґЕ“пЈїГ“Г‚ГЌГљГ‹пЈїГ“вЂљвЂЎГЊГ‹Г‚ Г‹ГЊГЉГ‚ГЊГ‚пЈїГЊЛљД± Г‹ ГЊвЂЎГ›ЛњГЊЛљД± Г”пЈїГ‹ГЋГ“ГЉГ‚ГЊГ‹Г€ вЂљ Г’пЈїГ‚вЂ°Г‚ MATLABВЄ</a></font></strong></marquee></td>
	</tr>
</table>-->

<div align="right">
	<table BORDER=0 CELLPADDING=0 CELLSPACING=7 width="780" height="20">
		<tr>
			<td>		<!-- РЇРЅРґРµРєСЃ.Р”РёСЂРµРєС‚ -->
<div id="yandex_ad"></div>
<script type="text/javascript">
(function(w, d, n, s, t) {
    w[n] = w[n] || [];
    w[n].push(function() {
        Ya.Direct.insertInto(147077, "yandex_ad", {
            ad_format: "direct",
            font_size: 1,
            type: "horizontal",
            border_type: "ad",
            limit: 2,
            title_font_size: 1,
            border_radius: true,
            links_underline: true,
            site_bg_color: "FFFFFF",
            header_bg_color: "FEEAC7",
            border_color: "FBE5C0",
            title_color: "0000CC",
            url_color: "006600",
            text_color: "000000",
            hover_color: "0066FF",
            sitelinks_color: "0000CC",
            favicon: true,
            no_sitelinks: false
        });
    });
    t = d.getElementsByTagName("script")[0];
    s = d.createElement("script");
    s.src = "//an.yandex.ru/system/context.js";
    s.type = "text/javascript";
    s.async = true;
    t.parentNode.insertBefore(s, t);
})(window, document, "yandex_context_callbacks");
</script>
			
		</td>
		</tr>
	</table>
</div><table border="0" cellspacing="0" cellpadding="0" width="780">  <tr>    <td width="10" valign="top"></td>    <td valign="top"><h1 class="h1"><a class="h1" href="index.php">Optimization Toolbox 2.2 Руководство пользователя </a></h1>  <P><strong>А.Г.Трифонов. Оптимизация при наличии ограничений</strong></p>  <p>Как правило, общий подход к решению задач оптимизации при наличии ограничений состоит в замене исходной задачи с ограничениями на другую более легко реализуемую задачу и которая в последующем используется как основа для некоторых итерационных процессов. В качестве основной особенности первоначально предложенных методов можно отметить следующее: исходная задача с ограничениями заменяется на задачу без ограничений, но с применением метода штрафных функций вблизи или около налагаемых значений для ограничений. При таком подходе задача оптимизации при наличии ограничений решалась через введение некой последовательности параметризованных задач оптимизации без наложения ограничений, которые в пределе (выбранной последовательности) сходились к искомой задаче с ограничениями. В настоящее время такой подход считается относительно малоэффективным и, соответственно, был заменен на методы решения, основанными на формулировке и последующем решении так называемых уравнений Куна-Такера (КТ). В уравнениях КТ вводятся дополнительные предположения о характере ограничений и понятии оптимальности для задачи оптимизации при наличии ограничений. Если поставленная задача является так называемой задачей выпуклого программирования, то есть <img border=0 width=27 height=18 src="images_14/image002.gif" align="absmiddle"> и <img border=0 width=116 height=22 src="images_14/image039.gif" align="absmiddle"> являются выпуклыми функциями, то уравнения КТ являются необходимыми и достаточными условиями для общей постановки задачи.</p>  <p>Применительно к уравнению (3-1) (GP) уравнения Куна-Таккера записываются в виде</p>  <table  border=0 cellspacing=0 cellpadding=0 width="100%"  >  <tr>   <td>   <p><img border=0 width=391   height=107 src="images_14/image040.gif" align="absmiddle"> </p>   </td>   <td align="right">   <p><b>(3-26)</b></p>   </td>  </tr> </table>    <p>Первые уравнения представляют собой описание процесса исчезновения градиента между целевой функцией и активными ограничениями в точке решения. Поскольку градиенты подлежат выходу на нулевые значения, то множители Лагранжа (<img border=0 width=92 height=22 src="images_14/image041.gif" align="absmiddle">) будут необходимы для того, что бы уравновесить отклонения по величине данной целевой функции и градиентов ограничений. Поскольку только активные ограничения вовлечены в данную процедуру оюнуления, то ограничения не активны и не должны подвергаться данной процедуре и поэтому соответствующие множители Лагранжа будут равны нулю. Это обстоятельство неявно выражено в двух последних уравнениях 3-26.</p>  <p>Подобное решение уравнений Куна-Таккера служит основой для большинства алгоритмов нелинейного программирования. В этих алгоритмах часто используется прямое вычисление множителей Лагранжа. Квазиньютоновские методы обеспечивают сверхлинейную сходимость путем накопления информации второго порядка относительно уравнений Куна-Таккера, использующих процедуры квазиньютоновской корректировки. В общем случае эти методы можно отнести к задачам Последовательного квадратичного программирования (SQP), поскольку проблема QP решается на каждой главной итерации (иногда их еще называют методами Итерационного квадратичного программирования, Рекурсивного квадратичного программирования или Переменной метрики при наличии ограничений).</p><a name="1"></a>  <P><strong>Последовательное квадратичное программирование SQP</strong></P><P>SQP метод является одним из самых современных методов в области нелинейного программирования. Шитковский [38], к примеру, успешно реализовал и провел тестовые расчеты по данной версии оптимизации и получил всестороннее превосходство, по сравнению с другими тестовыми методами, в части эффективности, точности и процента успешного решения задачи для большого числа тестовых задач. <br><br>Основанный на работах Бигса [1], Хана [24] и Пауэлла ([34], [35]) данный метод позволяет достаточно точно имитировать метод Ньютона для оптимизации при наличии ограничений, как это сделано для оптимизации без наличия ограничений. На каждой основной итерации осуществляется аппроксимация Гессиана для функций Лагнранжа при помощи квазиньютоновского модифицированного метода. Такой подход далее будет востребован для постановки подзадачи QP, решение которой далее уже используется для формирования направления поиска в процедуре линейного поиска. Обзор методов SQP можно найти в работах Флетчера [15], Гиль и др. [21], Пауэлла [37] и Шитковского [25]. Тем не менее, далее приводится описание обобщенного метода. <br><br>Согласно описанию задачу метода GP (уравнение 3-1) основная идея постановки подзадачи QP заключается в квадратичной аппроксимации функции Лагранжа.</P>  <table width="100%" cellspacing="0" cellpadding="0" border="0"><tr>    <td><img src="images_15/image001.gif" align="absmiddle"></td>    <td align="right"><strong>(3-27)</strong></td></tr></table><P>Последнее представляет собой упрощение уравнения 3-1 при предположении, что связанные ограничения могут быть представлены через ограничения в виде неравенств. Посредством линеаризации нелинейных ограничений можно получить подзадачу QP.<br><br><a name="2"></a><strong>Подзадача квадратичного программирования (QP)</strong></P><table width="100%" cellspacing="0" cellpadding="0" border="0"><tr>    <td><img src="images_15/image002.gif" align="absmiddle"></td>    <td align="right"><strong>(3-27)</strong></td></tr></table><P>Данная подзадача может быть решена посредством применения алгоритма QP (см., например, раздел Решение квадратичного программирования). Такое решение основано на формировании новой итерации следующего вида</P>  <p><img width=114 height=22 src="images_15/image003.gif" align="absmiddle"></p>    <p>Параметр при длине шага <img width=19 height=22 src="images_15/image004.gif" align="absmiddle"> определяется из соответствующей процедуры линейного поиска, которая обеспечивает приемлемое уменьшение получаемой функции выгоды (см. раздел Корректировка матрицы Гессе). Матрица <img width=23 height=22 src="images_15/image005.gif" align="absmiddle"> является положительно определенной аппроксимацией матрицей Гессе для Лагранжевой функции. (уравнение 3-27). <img width=23 height=22 src="images_15/image005.gif" align="absmiddle"> может быть корректироваться посредством любого из квазиньютоновских методов, хотя метод BFGS (смотри раздел Корректировка матрицы Гессе), скорее всего, является наиболее популярным. </p>  <p>В отличие от решения методом SQP для задач без ограничений, нелинейные задачи при наличии ограничений решаются за некоторое число итераций. Одной из причин такого факта является то, что, вследствие наличия пределов на обозримые области, оптимизатор может принимать осознанные решения относительно направлений поиска и размера шага. </p>  <p>Рассмотрим функцию Розенброка (уравнение 3-2) при наличии дополнительных нелинейных ограничений в виде неравенств, <em>g(x)</em>,</p>  <table  border=0 cellspacing=0 cellpadding=0  width="100%" >  <tr>   <td>   <p><img width=99 height=27   src="images_15/image006.gif" align="absmiddle"> </p>   </td>   <td align="right">   <p><b>(3-29)</b></p>   </td>  </tr> </table>   <p>При применении метода SQP эта задача решается за 96 итераций по сравнению с 140 итерациями для задач без ограничений. На рисунке 3-6 представлен путь к точке решения <img width=126 height=18 src="images_15/image007.gif" align="absmiddle"> начиная со стартовой точки <img width=78 height=18 src="images_15/image008.gif" align="absmiddle">.</p>  <p><img width=480 height=329 src="images_15/image009.gif" align="absmiddle"></p>  <p>Рис. 3-6. Применение метода SQP для функции Розенброка (уравнение 3-2) с линеаризованными нелинейными ограничениями</p>  <a name="3"></a>  <p><b>Реализация метода SQP</b></p>    <p>Реализация метода SQP состоит из трех основных стадий, которые далее кратко обсуждаются в следующих подразделах</p><ul>    <p><li> <b>Корректировка матрицы Гессе</b> для Лагранжевой функции.</p>  <p><li> <b>Решение задачи квадратичного программирования.</b></p>  <p><li> Вычисление <b>линейного поиска и функции выгоды</b></p></ul>    <a name="4"></a>  <p><b>Корректировка матрицы Гессе</b></p>  <p>На каждой главной итерации положительно определенная квазиньютоновская аппроксимация для функции Лагранжа , <em>H</em>, рассчитывается с помощью метода BFGS, где <img width=95 height=22 src="images_15/image010.gif" align="absmiddle">представляют собой оценку множителей Лагранжа.</p>    <table  border=0 cellspacing=0 cellpadding=0  width="100%" >  <tr>   <td>   <p>&nbsp;<img width=183 height=52 src="images_15/image011.gif" align="absmiddle">,   где</p>   </td>   <td align="right">   <p><b>(3-30)</b></p>   </td>  </tr> </table>  <p><img width=412 height=84 src="images_15/image012.gif" align="absmiddle"></p>    <p>Пауэл вообще [35] рекомендует поддерживать значения матрицы Гессе положительно определенными, даже не смотря на то, что в точке эти решения могут и не иметь положительные решения. Положительные значения матрицы Гессе поддерживаются в том случае, если величина <img width=34 height=24 src="images_15/image013.gif" align="absmiddle"> будет больше нуля для  каждой корректировки и, что <em>H </em>инициализируется как положительно определенная матрица. Когда величина <img width=34 height=24 src="images_15/image013.gif" align="absmiddle"> не является положительной, то параметр <img width=18 height=22 src="images_15/image014.gif" align="absmiddle"> модифицируется поэлементно, шаг за шагом, так что бы выполнялось условие <img width=55 height=24 src="images_15/image015.gif" align="absmiddle">. Обобщенная цель такой модификации заключается в том, что бы несколько изменить элементы <img width=18 height=22 src="images_15/image014.gif" align="absmiddle">, которые составляют основной вклад в положительно определенную корректировку, как можно меньше. Таким образом, на начальной стадии принятой модификации, отрицательный наибольший элемент их набора <img width=42 height=22 src="images_15/image016.gif" align="absmiddle"> последовательно уменьшается на половину. Такая процедура продолжается до тех пор, пока <img width=34 height=24 src="images_15/image013.gif" align="absmiddle"> больше или равна 1<em>e</em>-5. Если после такой процедуры <img width=34 height=24 src="images_15/image013.gif" align="absmiddle"> все равно остается положительной, то производится модификация y <img width=18 height=22 src="images_15/image014.gif" align="absmiddle"> путем добавления некого вектора  <em>v, </em>умноженного на некую скалярную постоянную <em>w</em>, а именно,</p>    <table  border=0 cellspacing=0 cellpadding=0  width="100%" >  <tr>   <td>   <p><img width=85 height=22 src="images_15/image017.gif" align="absmiddle"> </p>   </td>   <td align="right">   <p><b>(3-31)</b></p>   </td>  </tr> </table>   <p>где</p>  <p><img width=286 height=22 src="images_15/image018.gif" align="absmiddle"></p>    <p>если <img width=75 height=23 src="images_15/image019.gif" align="absmiddle"> и </p>    <p><img width=164 height=23 src="images_15/image020.gif" align="absmiddle"></p>    <p><img width=44 height=22 src="images_15/image021.gif" align="absmiddle"></p>    <p>или же в противном случае методично увеличивают <em>w</em> до тех пор, пока член <img width=34 height=27 src="images_15/image022.gif" align="absmiddle"> станет положительным.</p>  <p>Программы fmincom, fvinmax, fgoalattain и fseminf реализованы на основе метода SQP. Если опционный параметр Display установлен как отображение информации на каждой итерации 'iter', то выводится различная информация, включая значение функции и максимальное нарушение поставленных ограничений. Также отображается модифицированный Гессиан, в случае, если он претерпевает некую коррекцию на первоначальной стадии выполняемой процедуры с целью поддержания его положительного значения. Если Гессиан подвергается вторичной корректировке на второй стадии приведенного выше подхода, то отображается его вторичное значение. Если подзадача QP не является выполнимой, то этот факт так же отображается. Такая отображаемая информация, как правило, не представляет особого интереса, но указывает на то, что данная задача является существенно нелинейной, а сходимость может быть более длительной, чем обычно. Иногда отображаемое сообщение не изменяется, что указывает, что величина <img width=34 height=27 src="images_15/image023.gif" align="absmiddle"> будет порядка нуля. Это может указывать, что постановка задачи является неправильной или проводится оптимизация прерывистой функции.</p> <a name="5"></a>  <P><strong>Решение задачи квадратичного программирования.</strong></P>    <p>На каждой основной итерации метода SQP решается задача QP в следующей форме, где <img width=19 height=22 src="images_16/image001.gif" align="absmiddle"> относится к <code>i</code>-той стоке матрицы <img width=14 height=18 src="images_16/image002.gif" align="absmiddle"> размерностью <em>m х n:</em></p>    <table  border=0 cellspacing=0 cellpadding=0  width="100%" >  <tr>   <td>   <p><img width=259 height=85   src="images_16/image003.gif" align="absmiddle"> </p>   </td>   <td align="right">   <p><b>(3-32)</b></p>   </td>  </tr> </table>  <p>Используемый в тулбоксе Оптимизация метод основан на стратегии активных наборов (более известен как метод проекций) и аналогичен методу, описанному в работе Гиля и др., [20] [19]. Этот метод был модифицирован применительно для задач Линейного программирования (LP) и Квадратичного программирования (QP). </p>  <p>Процедура решения включает в себя две фазы. Первая фаза представляет собой расчет наиболее вероятной точки. Вторая фаза включает в себя генерацию некой итеративной последовательности наиболее вероятных точек, которая уже сходится к требуемому решению. В таком методе утверждается, что активный набор, <img width=21 height=23 src="images_16/image004.gif" align="absmiddle">, является некой оценкой активных ограничений (т.е. то, что представляет собой ограничительные пределы) в данной точке решения. Фактически все алгоритмы QP являются методами активных наборов. Это следует особо подчеркнуть, поскольку существует множество различных методов, которые чрезвычайно схожи по своей сути, но представлены в виде различных способов своего представления.</p>  <p><img width=21 height=23 src="images_16/image004.gif" align="absmiddle"> корректируется на каждой итерации и <em>k</em> используется для построения основы для направления поиска <img width=19 height=23 src="images_16/image005.gif" align="absmiddle">. Ограничения в виде равенств всегда остаются в данном активном наборе <img width=21 height=23 src="images_16/image004.gif" align="absmiddle">. Обозначение для переменной в виде <img width=19 height=23 src="images_16/image005.gif" align="absmiddle"> в данном случае используется для того, что бы различать эти переменные от <img width=25 height=28 src="images_16/image006.jpg">, используемых на главных итерациях метода SQP. Направление поиска <img width=19 height=23 src="images_16/image005.gif" align="absmiddle"> рассчитывается и далее используется для минимизации целевой функции, несмотря на то, что остаются в силе все возможные границы активных ограничений. Все возможное пространство для  переменных  <img width=19 height=23 src="images_16/image005.gif" align="absmiddle"> образуется из базиса <img width=20 height=22 src="images_16/image007.gif" align="absmiddle">, чьи колонки являются ортогональными относительно полученных результатов расчета активного набора <img width=21 height=23 src="images_16/image004.gif" align="absmiddle"> (т.е., <img width=66 height=25 src="images_16/image008.gif" align="absmiddle">). Таким образом, направление поиска, которое формируется путем суммирования всех возможных сочетаний колонок <img width=20 height=22 src="images_16/image007.gif" align="absmiddle">, обеспечивает сохранение границы активных ограничений. </p>  <p>Принятая матрица <img width=20 height=22 src="images_16/image007.gif" align="absmiddle"> формируется из последних <img width=34 height=18 src="images_16/image009.gif" align="absmiddle"> колонок разложения QR матрицы <img width=23 height=27 src="images_16/image010.gif" align="absmiddle">, где <em>l </em>есть число активных ограничений, а так же справедливо <em>l &lt; m</em>. Т.е. <img width=20 height=22 src="images_16/image007.gif" align="absmiddle"> определяется как</p>    <table  border=0 cellspacing=0 cellpadding=0  width="100%" >  <tr>   <td>   <p><img width=116 height=22 src="images_16/image011.gif" align="absmiddle"> </p>   </td>   <td align="right">   <p><b>(3-33)</b></p>   </td>  </tr> </table>  <p>где</p>    <p><img width=103 height=47 src="images_16/image012.gif" align="absmiddle"></p>    <p>Как только <img width=20 height=22 src="images_16/image007.gif" align="absmiddle"> будет найдено, то далее ищется новое направление поиска <img width=19 height=23 src="images_16/image005.gif" align="absmiddle">, которое в свою очередь приводит к минимуму <img width=32 height=18 src="images_16/image013.gif" align="absmiddle">, где <img width=19 height=23 src="images_16/image005.gif" align="absmiddle"> есть нулевое пространство активных ограничений. Т.е. <img width=19 height=23 src="images_16/image005.gif" align="absmiddle"> есть линейная комбинация столбцов  <img width=20 height=22 src="images_16/image007.gif" align="absmiddle">: <i><img width=65 height=25 src="images_16/image014.gif" align="absmiddle"> </i>для некоторого  вектора <em>p</em>. На следующем этапе, если при помощи соответствующей постановки для <img width=19 height=23 src="images_16/image005.gif" align="absmiddle"> ввести квадратное уравнение как некую функции от <em>p</em>, то получим:</p>  <table  border=0 cellspacing=0 cellpadding=0  width="100%" >  <tr>   <td>   <p><img width=192 height=34 src="images_16/image015.gif" align="absmiddle"> </p>   </td>   <td align="right">   <p><b>(3-34)</b></p>   </td>  </tr> </table>  <p>После дифференцирования по <em>p </em>получим</p>    <table  border=0 cellspacing=0 cellpadding=0  width="100%" >  <tr>   <td>   <p><img width=153 height=27 src="images_16/image016.gif" align="absmiddle"> </p>   </td>   <td align="right">   <p><b>(3-35)</b></p>   </td>  </tr> </table>  <p>Член <img width=42 height=18 src="images_16/image017.gif" align="absmiddle"> имеет отношение к проекции градиента квадратичной функции, поскольку он является проекцией градиента в подпространстве функций <img width=20 height=22 src="images_16/image007.gif" align="absmiddle">. Член <img width=52 height=29 src="images_16/image018.gif" align="absmiddle">есть так называемая проекция Гессиана. Полагая, что матрица Гессе <em>H </em>является положительно определенной (что справедливо применительно к реализации метода SQP), то минимум функции <em>q(p) </em>в подпространстве функций <img width=20 height=22 src="images_16/image007.gif" align="absmiddle"> будет определяться условием <img width=70 height=18 src="images_16/image019.gif" align="absmiddle">, и, следовательно, для поиска минимума функции необходимо решение системы линейных уравнений. </p>    <table  border=0 cellspacing=0 cellpadding=0  width="100%"  >  <tr>   <td>   <p><img width=110 height=27 src="images_16/image020.gif" align="absmiddle"> </p>   </td>   <td align="right">   <p><b>(3-36)</b></p>   </td>  </tr> </table>  <p>А шаг в направлении минимума будет в следующем виде</p>    <table  border=0 cellspacing=0 cellpadding=0 width="100%" >  <tr>   <td>   <p><img width=247 height=27 src="images_16/image021.gif" align="absmiddle"> </p>   </td>   <td align="right">   <p><b>(3-37)</b></p>   </td>  </tr> </table>  <p>Вследствие квадратичной природы целевой функции на каждой итерации следует, что существует только одно возможное значения размера шага <img width=13 height=18 src="images_16/image022.gif" align="absmiddle">. Единичный шаг в направлении <img width=19 height=23 src="images_16/image005.gif" align="absmiddle"> как раз и есть шаг в направлении минимума функции, ограниченной пределами нулевого пространства <img width=21 height=23 src="images_16/image004.gif" align="absmiddle">. Если будет возможно принять такой шаг, без нарушения принятых ограничений, то это как раз и будет решение QP (см. уравнение 3-33). В противном случае, шаг вдоль направления <img width=19 height=23 src="images_16/image005.gif" align="absmiddle"> в сторону ближайшего ограничения будет меньше единицы и в активный набор на следующей итерации будут включены новые ограничения. Расстояние до границ ограничений в любом направлении <img width=19 height=23 src="images_16/image005.gif" align="absmiddle"> можно представить как</p>    <table  border=0 cellspacing=0 cellpadding=0 width="100%"  >  <tr>   <td>   <p><img width=268 height=49 src="images_16/image023.gif" align="absmiddle"> </p>   </td>   <td align="right">   <p><b>(3-38)</b></p>   </td>  </tr> </table>  <p>Которое определено для ограничений не из активного набора и где направление <img width=19 height=23 src="images_16/image005.gif" align="absmiddle"> показывает направление к границам ограничений, т.е. <img width=138 height=25 src="images_16/image024.gif" align="absmiddle">.</p>  <p>В случае включения <em>n </em>независимых ограничений в активный набор, без локализации минимум, то для соответствия невырожденной системе линейных уравнений </p>    <table  border=0 cellspacing=0 cellpadding=0 width="100%"  >  <tr>   <td>   <p><img   width=64 height=29 src="images_16/image025.gif" align="absmiddle"> </p>   </td>   <td align="right">   <p><b>(3-39)</b></p>   </td>  </tr> </table>    <p>следует рассчитывать множители Лагранжа.</p>    <p>Если все элементы <img width=18 height=22 src="images_16/image026.gif" align="absmiddle"> больше нуля, то <img width=18 height=22 src="images_16/image027.gif" align="absmiddle"> является решением для точки оптимума задачи (уравнение 3-33). Однако, если какой-нибудь из элементов <img width=18 height=22 src="images_16/image026.gif" align="absmiddle"> будут меньше нуля, то эти компоненты не будут соответствовать ограничениям в виде равенств и, следовательно, соответствующий элемент необходимо определять из активного набора, так же требуется обращение к новой итерации.</p>    <p><b>Инициализация. </b>В данном алгоритме для успешного начала работы требуется некая допустимая стартовая точка. Если текущая точка из метода SQP не является допустимой, то тогда некую точку можно найти из решения задачи линейного программирования.</p>    <table  border=0 cellspacing=0 cellpadding=0  width="100%" >  <tr>   <td>   <p><img width=244 height=79   src="images_16/image028.gif" align="absmiddle"> </p>   </td>   <td align="right">   <p><b>(3-40)</b></p>   </td>  </tr> </table>  <p>Обозначение <img width=19 height=22 src="images_16/image001.gif" align="absmiddle"> указывает на <em>i-</em>ую точку матрицы. Допустимую точку для уравнения 3-40 можно найти (если таковая существует) путем установки х</em> в некое удовлетворяющее ограничениям типа равенство значение. Такое значение можно определить из решения недо- или переопределенной системы линейных уравнений, полученной из системы ограничений типа равенств. Если решение такой задачи существует, то фиктивная переменная <img width=12 height=18 src="images_16/image029.jpg"> устанавливается в данном случае как некое максимальное расхождение.</p>  <p>Упомянутый выше алгоритм QP можно модифицировать применительно к задачам LP путем установки на каждой итерации направления поиска в направление наискорейшего спуска, где <img width=19 height=22 src="images_16/image030.gif" align="absmiddle"> является градиентом взятой целевой функции (равенство коэффициентов линейной целевой функции).</p>    <table  border=0 cellspacing=0 cellpadding=0 width="100%"  >  <tr>   <td>   <p><img width=97 height=27 src="images_16/image031.gif" align="absmiddle"> </p>   </td>   <td align="right">   <p><b>(3-41)</b></p>   </td>  </tr> </table>  <p>Если после использования ранее упомянутого метода LP найдена некая допустимая точка, то, далее, запускается основная фаза метода QP. Направление поиска <img width=19 height=23 src="images_16/image005.gif" align="absmiddle"> инициализируется совместно с направлением поиска  <img width=19 height=23 src="images_16/image032.gif" align="absmiddle">, полученным из решения системы линейных уравнений</p>    <table  border=0 cellspacing=0 cellpadding=0 width="100%">  <tr>   <td>   <p><img width=74 height=25 src="images_16/image033.gif" align="absmiddle"> </p>   </td>   <td align="right">   <p><b>(3-42)</b></p>   </td>  </tr> </table>  <p>Где <img width=19 height=22 src="images_16/image030.gif" align="absmiddle">есть градиент целевой функции для текущей итерации <img width=18 height=22 src="images_16/image027.gif" align="absmiddle"> (т.е.<img width=51 height=22 src="images_16/image034.gif" align="absmiddle">).</p>  <p>Если для задачи QP невозможно определить допустимую точку, то направление поиска для основной подпрограммы SQP <img width=19 height=23 src="images_16/image005.gif" align="absmiddle"> принимается из условия минимизации величины <img width=10 height=18 src="images_16/image035.gif" align="absmiddle">.</p> <a href="6"></a> <p><b>Линейный поиск и функция выгоды</b></p>  <p>Решение подзадачи QP приводит к формированию вектора <img width=19 height=22 src="images_16/image036.gif" align="absmiddle">, который, в свою очередь, используется при формировании новой итерации типа</p>  <table  border=0 cellpadding=0 width="100%"  >  <tr>   <td>   <p><img width=108 height=22   src="images_16/image037.gif" align="absmiddle"> </p>   </td>   <td align="right">   <p><b>(3-43)</b></p>   </td>  </tr> </table>  <p>Для того, что бы получить достаточное уменьшение функции выгоды оценивается параметр длины шага <img width=19 height=22 src="images_16/image038.gif" align="absmiddle">. Реализованная в данном алгоритме функция выгоды была ранее использована Наном [24] и Поуэлом [35] и имеет следующий вид.</p>    <table  border=0 cellspacing=0 cellpadding=0  width="100%" >  <tr>   <td>   <p><img width=329 height=62 src="images_16/image039.gif" align="absmiddle"> </p>   </td>   <td align="right">   <p><b>(3-44)</b></p>   </td>  </tr> </table>  <p>Поуэл рекомендует введение следующего штрафного параметра:</p>    <table  border=0 cellspacing=0 cellpadding=0  width="100%" >  <tr>   <td>   <p><img width=338 height=49 src="images_16/image040.gif" align="absmiddle"> </p>   </td>   <td align="right">   <p><b>(3-45)</b></p>   </td>  </tr> </table>  <p>Данный подход дает положительный вклад от принятых ограничений, но которые являются неактивными для решения задачи QP, хотя ранее это были активные значения. В принятом методе реализации параметр штрафа в качестве исходного параметра имеет вид:</p>    <table  border=0 cellspacing=0 cellpadding=0  width="100%" >  <tr>   <td>   <p><img width=96 height=38 src="images_16/image041.gif" align="absmiddle"> </p>   </td>   <td align="right">   <p><b>(3-46)</b></p>   </td>  </tr> </table>  <p>Где <img width=27 height=18 src="images_16/image042.gif" align="absmiddle">представляет собой эвклидову норму. </p>  <p>Такой подход обеспечивает существенный вклад от ограничения с небольшими параметрами в значения штрафных параметров, что особенно актуально для активных ограничений вблизи точки решения. </p>  <a href="7"></a>  <p><b>Алгоритм симплексного метода</b></p>  <p>Предложенный еще Георгом Дантзигом в 1947 г. алгоритм симплексного метода является одним из самых ранних и наиболее известных методов оптимизации. Данный алгоритм решает следующую задачу линейного программирования</p>    <p><img width=265 height=72 src="images_16/image043.gif" align="absmiddle"></p>  <p>Данный алгоритм представляет собой продвижение вдоль краев многогранника, определенного принятыми ограничениями, от одной вершины к другой при снижении величины целевой функции, <em>f</em><sup>T</sup> x, на каждом шаге. Далее приводится описание улучшенной версии исходного метода симплексного алгоритма, который так же приводит к оптимальным решениям, находящихся на вершинах многоугольника.</p>  <a name="8"></a>  <P><strong>Основной алгоритм.</strong></P> <p>Алгоритм симплексного метода включает в себя две фазы:</p>    <p>Фаза 1. -  Расчет начальной основной допустимой точки.</p>  <p>Фаза 2. - Расчет оптимального решения согласно поставленной задаче.</p>  <p><b>Примечание. </b>Применительно к программе linprog нельзя принимать исходную точку х0 для расчета по алгоритму симплексного метода. Если все же х0 будет передано в качестве входного аргумента, то программа linprog игнорирует эту точку х0 и расчитывает свою  собственную начальную точку.</p>    <p><b>Фаза 1. </b>При выполнении фазы 1 в данном алгоритме определяется начальное основное допустимое решение (см. определения из раздела <b>Основные и неосновные переменные</b>) посредством решения кусочно-правильной вспомогательной задачи линейного программирования. Целевая функция этой вспомогательной задачи является <i>линейной штрафной функцией</i></p>    <p><img width=83 height=44 src="images_17/image001.gif" align="absmiddle">,</p>    <p>где члены <em>P</em><sub>j</sub>(<em>x</em><sub>j</sub>) определены как</p>    <p><img width=227 height=84 src="images_17/image002.gif" align="absmiddle"></p>    <p><em>P</em>(<em>x</em>) служит мерой того, как много точка <i>х </i>переступает нижний и верхний граничные условия. А вспомогательная задача будет</p>    <p><img width=261 height=50 src="images_17/image003.gif" align="absmiddle"></p>    <p>Исходная задача имеет допустимую базисную точку тогда и только тогда, когда вспмогательная задача имеет равное нулю минимальное значение. </p>  <p>В данном алгоритме ничальная точка для вспомогательной задачи определяется с помощью эвристического метода, который по мере необходимости добавляет неактивные и искусственные переменные. Далее согласно выбранному алгоритму эта начальная точка используется совместно с симплексным алгоритмом для решения вспомогательной задачи. Такое оптимальное решение, в свою очередь, является начальной точкой для фазы 2 основного алгоритма.</p>    <p><b>Фаза 2. </b>Согласно фазе 2, для решения исходной поставленной задачи в данном алгоритме используется симплексный алгоритм, начиная уже с начальной стартовой точки фазы 1. На каждой итерации в данном алгоритме проводится проверка условии оптимальности и задача останавливается в случае, если текущие решения оказывается оптимальным. Если текущее решение не оптимально, то согласно данному алгоритму проводятся следующие действия:</p><ul>  <p><li> Выбирается одна переменная, называемая как <i>вводимая переменная</i>, из небазисных переменных и добавляется соответствующая колонка из небазисного вида в рассматриваемый базисный вид (в соответствии с принятыми определениями см. раздел <b>Базисные и небазисные переменные</b>).</p>  <p><li> Выбирается некая переменная, (так называемая <i>исключаемая переменная</i>) из набора базисных переменных и из базисного набора удаляется соответствуюшая колонка.</p>  <p><li> Проводится корректировка текущего решения и значения текущей цели. </p></ul>  <p>Выбор вводимых и исключаемых переменных производится путем решения двух систем линейных уравнений, при сохранении свойства допустимости решения.</p>   <a href="9"></a> <p><b>Предварительная подготовка.</b></p>    <p>В алгоритме симплексного метода используются те же самые подготовительные операции, что и  в решателе задачи линейного программирования для алгоритмов большой размерности, как это отмечено в одноименном разделе. Дополнительно, в данном алгоритме используются еще две операции:</p>  <p>Исключаются колонки, которые имеют только один ненулевой элемент, а так же исключаются их соответствующие строчки.</p>  <p>Для каждого уравнения из числа ограничений <img width=57 height=18 src="images_17/image004.gif" align="absmiddle">, где <em>a</em>  есть строчные елементы для <em>Aeq</em>, в данном алгоритме для линейной комбинации <img width=29 height=18 src="images_17/image005.gif" align="absmiddle"> в виде <em>rlb</em> и <em>rub, </em>рассчитываются нижняя и верхняя границы. Такой подход является справедливым в случае конечных значений нижней и верхней границ. Если или <em>rlb</em> или <em>rub</em> равно <em>b</em>, то эта константа называется <i>принудительным ограничением</i>. В данном алгоритме каждый раз устанавливается некая переменная соответствующая ненулевоиу коэффициенту из <img width=29 height=18 src="images_17/image005.gif" align="absmiddle">, равному его верхней или нижней границе в зависимости от принудительного ограничения. Далее согласно алгоритму удаляются колонки, соответствующие этим переменным, а так же удаляются соответствующие принудительным ограничениям строчки.</p>  <a name="10"></a>  <p><b>Использование симлексного алгоритма.</b></p>    <p>Для того, что бы установить использование алгоритма симплексного метода, следует установить опционные параметры следующего типа</p>    <p>'LargeScale' в 'off' и 'Simplex' в 'on'.</p>    <p>options = optimset('LargeScale', 'off', 'Simplex', 'on')</p>    <p>Далее вызывается функция linprog с соответствующими входными опциями и аргументами. Детали использования функции linprog приведены соответсвующем разделе. </p>  <p>В ситуации если программа определит недопустимость или наличие неограниченнности при выполнении процедуры предварительной подготовки данных, то Linprog возвращает пустые выходные аргументы на месте x и fval. Linprog возвращает значение текущей точки в ситациях, когда</p><ul>  <p><li> Есть превышение максимального числа итераций.</p>  <p<li> Будет определено, что поставленная задача является невыполнимой или не имеющей границ относительно фаз 1 и 2. </p>  <p><li> Когда задача не имеет предельных границ, то linprog возвращает значения x и fval относительно направления отсутствия предельных границ.</p></ul>  <a name="11"></a>  <p><b>Основные и неосновные переменные.</b></p>    <p>В данном разделе дается определение таких терминов, как базис, небазис и базисное допустимое решение для задачи линейного программирования. Для данных определений примем, что поставленная задача имеет следующий стандартный вид:</p>    <p><img width=238 height=50 src="images_17/image006.gif" align="absmiddle"></p>    <p>(Отметим, что <em>A</em> и <em>b </em>не являются некими матрицей или вектором, определяющими неравенства в исходной задаче). Предположим, что <em>A</em> есть матрица размерностью <em>m</em>-х-<em>n</em> с рангом <em>m</em> &lt; <em>n</em> и соотвествующими колонками {<em>a</em><sub>1</sub>,&nbsp;<em>a</em><sub>2</sub>,&nbsp;...,&nbsp;<em>a</em><sub>n</sub>}. Примем, что <img width=102 height=23 src="images_17/image007.gif" align="absmiddle"> является пространством колонок <em>A</em>, с набором индексов <em>B</em> = {<em>i</em><sub>1</sub>, <em>i</em><sub>2</sub>, ..., <em>i</em><sub>m</sub>} и <em>N</em> = {1,&nbsp;2,&nbsp;...,&nbsp;n}. <em>N</em> является дополнением <em>B</em>. Субматрица <em>A</em><sub>B</sub> есть так называемый <i>базис</i>, а дополнительная субматрица <em>A</em><sub>N</sub> есть так называмый <i>небазис</i>.  <em>x</em><sub>B  </sub> есть вектор <i>базисных переменных </i>и <em>x</em><sub>N</sub> есть вектор <i>небазисных переменных</i>. При выполнении каждой итерации фазы 2 данного алгоритма производится замена одной колонки текущего базиса на колонку небазиса и, соответственно, корректируются переменные <em>x</em><sub>B</sub> и <em>x</em><sub>N</sub>.</p>  <p>Если <i>х</i> есть решение системы <img width=60 height=22 src="images_17/image008.gif" align="absmiddle"> и все небазисные переменные для <em>x</em><sub>N</sub> равны или их нижней или верхней границе, то х называется <i>базисным решением</i>. </p>  <a href="12"></a>  <p><b>Литература</b></p>    <p>[1] &nbsp;Chvatal, Vasek, <em>Linear Programming</em>, W. H. Freeman and Company, 1983. </p>  <p>[2] &nbsp;Bixby, Robert E., &quot;Implementing the Simplex Method: The Initial Basis,&quot; ORSA Journal on Computing, Vol. 4, No. 3, 1992. </p>  <p>[3] &nbsp;Andersen, Erling D. and Knud D. Andersen, &quot;Presolving in Linear Programming,&quot; Mathematical Programming, Vol. 71, pp. 221-245, 1995. </p>          </td>    <td width="10" valign="top"></td>  </tr></table><br>
<table border="0" cellpadding="10" cellspacing="0" width="780px" bgcolor="#FFCE9D">
	
	<tr>
	<td width="780px">
		Поиск по сайту:<br/>
		<div class="ya-site-form ya-site-form_inited_no" onclick="return {'action':'http://yandex.ru/sitesearch','arrow':false,'bg':'transparent','fontsize':12,'fg':'#000000','language':'ru','logo':'rb','publicname':'Yandex Site Search #2046777','suggest':true,'target':'_blank','tld':'ru','type':2,'usebigdictionary':true,'searchid':2046777,'webopt':false,'websearch':false,'input_fg':'#000000','input_bg':'#FFFFFF','input_fontStyle':'normal','input_fontWeight':'normal','input_placeholder':null,'input_placeholderColor':'#000000','input_borderColor':'#7F9DB9'}"><form action="http://yandex.ru/sitesearch" method="get" target="_blank"><input type="hidden" name="searchid" value="2046777"/><input type="hidden" name="l10n" value="ru"/><input type="hidden" name="reqenc" value=""/><input type="text" name="text" value=""/><input type="submit" value="Найти"/></form></div><style type="text/css">.ya-page_js_yes .ya-site-form_inited_no { display: none; }</style><script type="text/javascript">(function(w,d,c){var s=d.createElement('script'),h=d.getElementsByTagName('script')[0],e=d.documentElement;if((' '+e.className+' ').indexOf(' ya-page_js_yes ')===-1){e.className+=' ya-page_js_yes';}s.type='text/javascript';s.async=true;s.charset='utf-8';s.src=(d.location.protocol==='https:'?'https:':'http:')+'//site.yandex.net/v2.0/js/all.js';h.parentNode.insertBefore(s,h);(w[c]||(w[c]=[])).push(function(){Ya.Site.Form.init()})})(window,document,'yandex_site_callbacks');</script>
		</td>
	</tr>
	
	
	<tr>
	<td colspan="2" height="2">
	<div align="center">
	<script type="text/javascript" src="http://yandex.st/share/share.js"	charset="utf-8"></script>
	<div class="yashare-auto-init" data-yashareL10n="ru" data-yashareType="button" data-yashareQuickServices="yaru,vkontakte,facebook,twitter,odnoklassniki,moimir,lj,gplus"></div>
	
	

	</div>
	
	

	
		<br/>
		<div align="right">
			<a href="http://matlab.exponenta.ru/copyright.php">Copyright 2001&ndash;2014 Softline Co&nbsp;&nbsp;</a><br>
			
		</div>
	

	<tr>
		<td>
			
			<!--<a href="https://www.youtube.com/user/MATLABinRussia" target="_blank" rel="nofollow" alt="Канал на Youtube, полностью посвященный MATLAB и Simulink" >
			<img src="http://matlab.exponenta.ru/images/youtube2.png" alt="Канал на Youtube, полностью посвященный MATLAB и Simulink" title="Канал на Youtube, полностью посвященный MATLAB и Simulink" border="1" />
			</a>-->
			<script type="text/javascript" src="http://matlab.exponenta.ru/orphus/orphus.js"></script>
<a href="http://orphus.ru/" id="orphus" target="_blank"><img alt="Система Orphus" src="http://matlab.exponenta.ru/orphus/orphus.gif" border="0" width="257" height="48" /></a>
		</td>
		<td>
			<p align=right><div align=right>
			
			<!-- Yandex.Metrika informer -->
			<a href="http://metrika.yandex.ru/stat/?id=20978398&from=informer"
			target="_blank" rel="nofollow"><img src="http://bs.yandex.ru/informer/20978398/3_0_FFFFFFFF_EFEFEFFF_1_pageviews"
			style="width:88px; height:31px; border:0;" alt="Яндекс.Метрика" title="Яндекс.Метрика: данные за сегодня (просмотры, визиты и уникальные посетители)" onclick="try{Ya.Metrika.informer({i:this,id:20978398,lang:'ru'});return false}catch(e){}"/></a>
			<!-- /Yandex.Metrika informer -->

			<!--/COUNTER--></div>
			</td>
	
		
	</tr>
</table>
</td>
</tr>
</table>
</table></body></html>